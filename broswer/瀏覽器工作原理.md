# 瀏覽器工作原理
###### tags: `瀏覽器`
### 執行緒與行程
#### 行程是什麼？
* 電腦中已執行程式的實體。
* 執行緒的容器。
* 擁有自己的地址空間，包括**文字區域（text region）**、**數據區域（data region）** 和 **堆栈（stack region）**。

#### 執行緒是什麼？
* 依附於行程。
* 不能單獨存在，由行程來啟動和管理。
* 行程中的實際運作單位。

#### 執行緒＆行程關係
* 行程中使用多執行緒並行處理能提升運算效率。
* 行程中任意執行緒執行錯誤，都會導致整個行程的崩潰。
* 執行緒之間共享行程中的數據。
* 當一個行程關閉之後，操作系統會回收行程所佔用的RAM。
* 行程之間的內容相互隔離。

![](https://i.imgur.com/yGW960L.png)
### Chrome 從單行程到多行程/程序架構

#### 為什麼從單行程架構轉到多行程架構？
多功能模塊運行在一個行程裡，是導致單行程瀏覽器不穩定、不流暢和不安全的一個主要因素。
![](https://i.imgur.com/5HF52wc.png)
* 不穩定
    * **一個插件的意外崩潰會引起整個瀏覽器的崩潰**
        * **早期**瀏覽器需要藉助於插件來實現諸如Web視頻、Web遊戲等各種強大的功能，運行在瀏覽器行程之中。
* 不流暢
    * 所有頁面的渲染模塊、JavaScript執行環境以及插件都是運行在同一個執行緒中的，這就意味著同一時刻只能有一個模塊可以執行。
    * 執行以下程式碼後，因為瀏覽器中所有的頁面都運行在該執行緒中，所以這些頁面都沒有機會去執行任務，這樣就會導致整個瀏覽器失去響應，變卡頓。
```bash=
function freeze() {
  while (1) {
    console.log("freeze");
  }
}
freeze();
```
* 不安全
    * 當你在頁面運行一個插件時也就意味著這個插件能完全操作你的電腦。如果是個惡意插件，那麼它就可以釋放病毒、竊取你的帳號密碼，引發安全性問題。

#### 多行程如何解決這些問題？
* 不穩定
    * 行程是相互隔離的，所以當一個頁面或者插件崩潰時，影響到的僅僅是當前的頁面行程或者插件行程，並不會影響到瀏覽器和其他頁面。
* 不流暢
    * 跟上述一樣，行程是互相隔離，即使JavaScript阻塞了渲染行程，影響到的也只是當前的渲染頁面，而並不會影響瀏覽器和其他頁面。
* 不安全
    * [安全沙箱](https://zh.wikipedia.org/wiki/%E6%B2%99%E7%9B%92_(%E9%9B%BB%E8%85%A6%E5%AE%89%E5%85%A8))
#### 為什麼單行程不能使用安全沙箱
* 如果一個行程使用了安全沙箱之後，該行程對於操作系統的權限就會受到限制，比如不能對一些位置的文件進行讀寫操作，而這些權限瀏覽器主行程所需要的，所以安全沙箱是不能應用到瀏覽器主行程之上。
<!-- 
#### 多行程的優缺點
1. 優點：
    * 提升瀏覽器穩定性（每個行程都會包含公共基礎結構的副本）。
    * 提升瀏覽器流暢性和安全性。
2. 缺點：
    * 更高的資源佔用。
    * 更複雜的體系架構。 -->

#### chrome多行程架構圖
現在打開1個頁面至少需要1個網路行程、1個瀏覽器行程、1 個GPU行程以及1個渲染行程，共4個；如果打開的頁面有運行插件的話，還需要再加上1個插件行程。（可以打開工作管理員查看）
![](https://i.imgur.com/Yyb9kAa.png)
* **瀏覽器主行程：**
主要負責界面顯示、用戶交互、子行程管理，同時提供文件存儲等功能。
* **渲染行程：**
核心任務是將HTML、CSS和JavaScript轉換為用戶可以與之交互的網頁，排版引擎Blink和JavaScript引擎V8都是運行在該行程中。
* **GPU行程：**
GPU的使用初衷是為了實現3D CSS的效果，只是隨後網頁、Chrome的UI界面都選擇採用GPU來繪製，這使得GPU成為瀏覽器普遍的需求。最後，Chrome在其多行程架構上也引入了GPU行程。
* **網路行程：**
主要負責頁面的網絡資源加載。

* **插件行程：**
主要是負責插件的運行，因插件易崩潰，所以需要通過插件行程來隔離，以保證插件行程崩潰不會對瀏覽器和頁面造成影響。


### 如何保證頁面文件能被完整送達瀏覽器？
![](https://i.imgur.com/cJaxdwU.png)
網際網路，是一套理念和協議組成的體系架構。
網際網路中的數據是通過封包來傳輸的。如果發送的數據很大，那麼該數據就會被拆分為很多小封包來傳輸。

**1. IP-把封包送達目的主機**
* 封包要在網際網路上進行傳輸，就要符合網際協議（Internet Protocol，簡稱IP）標準。
* **計算機的地址就稱為IP地址，訪問任何網站實際上只是你的計算機向另外一台計算機請求資訊。**

**2. UDP/TCP協定**
* **UDP（User Datagram Protocol）**
    *  位於OSI網路參考模型的**第四層傳輸層**中的一種網路通訊協定。
    *  **非連線型**：不通知傳送目標要開始傳送訊息的情況下，突然進行送訊的一種方式，因此在通訊上的可靠性較低，但若與TCP比較，則因為其通訊協定本身的負擔較輕，所以速度會比較快。
    *  不會運用確認機制來保證資料是否正確的被接收，也不必按照順序，不需重新傳送遺失的資料，也不提供回傳機制來控制資料流的速度。
    *  若要傳輸像*語音*、*影像*等**訊息量較大**的資料，**可以容忍遺失一些封包**，會建議使用UDP協定。
    * UDP中一個重要的資訊是**通訊埠**，通訊埠其實就是一個數字，每個想訪問網路的程序都需要綁定一個通訊埠。
* **TCP（Transmission Control Protocol）**
    *  也同樣位於OSI網路參考模型的第四層傳輸層中的一種網路通訊協定。
    *  提供的是一個**可靠的連線導向**的資料流傳輸機制，**負責發送端與接收端的協定建立**。
    *  確保資料通訊的正確傳輸，提供 **流量控制（flow control）** 的特性。
    *  TCP會在接收會議層以上的通訊協定而來的資料之後，將其分割成較小封包，以便於傳輸，在將資料分割成封包時就會先**附上序列編號**，以確保封包排列的正確性。
    *  **TCP連接過程**
        1. 建立連線 
            * **三向式的握手程序**:
                * 連線請求，連線確認，連接成功。
        2. 傳送數據
            * 接收端需要對每個封包進行確認操作。
        3. 斷開連接
            * 數據傳輸完畢之後，就要終止連接了。
* TCP與UDP比較

|          |      TCP       |                UDP                 |
| -------- |:--------------:|:----------------------------------:|
| 連接特性 | 可靠的連接導向 |         非可靠的非連接導向         |
| 速度     |       慢       |                 快                 |
| 穩定性   |       高       |                 低                 |
| 握手程序 |      需要      |               不需要               |
| 優點     | 可靠的傳輸機制 |           傳輸量大，迅速           |
| 缺點     |    速度較慢    | 不可靠，應用程式需自行提供可靠機制 |


### HTTP請求流程
HTTP是一種允許瀏覽器向服務器獲取資源的協議，是Web的基礎，通常由瀏覽器發起請求，用來獲取不同類型的文件。
![](https://i.imgur.com/NDa9SRD.png)

* **瀏覽器端發起HTTP 請求流程**
1. 構建請求
    * 瀏覽器構建請求行信息（如下所示），構建好後，瀏覽器準備發起網絡請求。
  ```bash=
  GET /index.html HTTP1.1
  ```
2. 查找緩存
    * 在**真正發起網絡請求之前**，會先在瀏覽器緩存中查詢是否有要請求的文件。若存有副本，它會攔截請求，返回該資源的副本，**並直接結束請求**，不會再去代理服務器重新下載。**若緩存查找失敗，就會進入網路請求過程。**
    * 好處：
        * 緩解伺服器端壓力，提升性能（獲取資源的耗時更短）。
        * 對於網站來說，緩存是實現快速資源加載的重要組成部分。
3. 準備IP地址和通訊埠
    * 瀏覽器使用HTTP協議作為**應用層協議**，用來封裝請求的文字資訊，並**使用TCP/IP作傳輸層協議**將它發到網絡上。
    * **HTTP的內容是通過TCP的傳輸數據階段來實現的。**
4. 等待TCP佇列
    * 一個域名同時最多只能建立**6個**TCP連接，如果超過，其餘請求會進入佇列等待狀態，直至進行中的請求完成;如果當前請求數量少於6，會直接進入下一步，建立TCP 連接
5. 建立TCP 連接
6. 發送HTTP 請求

* **伺服器端處理HTTP請求流程**
7. 返回請求
8. 斷開連接
    * **保持TCP連接可省去下次請求時需要建立連接的時間，提升資源加載速度。**
![](https://i.imgur.com/y8zkaYc.png)
9. 重定向 
![](https://i.imgur.com/ARXFIkb.png)


### 輸入URL到頁面展示過程
用戶發出URL請求到頁面開始解析的這個過程，叫做**導航**。
![](https://i.imgur.com/sLmw5vS.png)

1. 用戶輸入
    * 判斷輸入的關鍵字是搜索內容，還是請求的URL。
    * 可以通過`beforeunload`事件來取消導航，讓瀏覽器不再執行任何後續工作。
2. URL請求過程
    * 瀏覽器行程會通過行程間通信（IPC）把URL請求發送至網絡行程，**網絡行程接收到URL請求後，會在這裡發起真正的URL請求流程。**
    * 查找緩存：
        * 有緩存：直接返回資源給瀏覽器行程。
        * 沒有緩存： 進入網絡請求流程，先進行DNS解析，以獲取請求域名的服務器IP地址。如果請求協議是HTTPS，那麼還需要建立TLS連接。
3. 準備渲染行程
    * 默認情況下，Chrome會為每個頁面分配一個渲染行程，每打開一個新頁面就會配套創建一個新的渲染行程 
    * 在**同一站點**情況下，瀏覽器會讓多個頁面直接運行在同一個渲染行程中，新頁面會復用父頁面的渲染行程。
    * 同一站點：定義為**根域名**（例如：geekbang.org）加上協議（例如：https:// 或者 http:// ）
4. 提交文檔
    * 瀏覽器行程將網絡行程接收到的HTML數據提交給渲染行程。
        * 瀏覽器行程接收到網絡行程的響應頭數據之後，便向渲染行程發起"提交文檔"的消息。
        * 渲染行程接收到"提交文檔"的消息後，會和網路行程建立傳輸數據的"管道"，數據傳輸完成，渲染行程會返回"確認提交"的消息給瀏覽器行程。。
    * 瀏覽器行程在收到「確認提交」的消息後，會更新瀏覽器界面狀態，包括了安全狀態、地址欄的URL、前進後退的歷史狀態，並更新Web=頁面。
    
![](https://i.imgur.com/QslAQ76.png)

### 渲染流程
* 瀏覽器根據標籤的語意來展示HTML內容。
![](https://i.imgur.com/nlu4o4l.png)
* 每個子階段都有其**輸入的內容**，**處理過程**，以及**輸出內容**。
* 按照渲染的時間順序，流水線可分為以下幾個子階段：
    1. 構建DOM樹
    2. 樣式計算
    3. 佈局階段
    4. 分層
    5. 繪製
    6. 分塊
    7. 柵格化和合成
#### 構建DOM樹
![](https://i.imgur.com/fDaJOsg.png)
* 瀏覽器無法直接理解和使用HTML，所以需要將HTML轉換為瀏覽器能夠理解的結構-DOM樹。
![](https://i.imgur.com/SwngZfr.png)
* 每個點我們稱節點，相連的節點稱父子節點。
* DOM樹構建過程
![](https://i.imgur.com/rndDHxZ.png)

#### 樣式計算
![](https://i.imgur.com/fTOXs3X.png)
1. 將CSS轉換為瀏覽器能理解的結構
    * 當渲染引擎接收到CSS文本時，會執行一個轉換操作，將CSS文本轉換為瀏覽器可以理解的結構—**styleSheets**。
![](https://i.imgur.com/GkF0MH4.png)

2. 轉換樣式表中的屬性值，使其標準化
    * 需要將所有值轉換為渲染引擎容易理解的、標準化的計算值。
![](https://i.imgur.com/u1f9jSQ.png)

3. 計算DOM樹中每個節點的具體樣式
    * 計算過程中需要遵守CSS 的**繼承**和**層疊**兩個規則。這個階段最終輸出的內容是每個DOM節點的樣式，並被保存在**ComputedStyle**的結構內。

![](https://i.imgur.com/WisDGBy.png)

#### 佈局階段
![](https://i.imgur.com/TXEia5Q.png)
* 計算DOM樹中**可見元素**的幾何位置，我們把這個過程叫做佈局。
    * chrome在佈局階段需要完成兩個任務：
        1.創建佈局樹
        ![](https://i.imgur.com/gHSeBAN.png)
        2.佈局計算
        *  執行佈局操作時，會把佈局運算的結果重新寫回佈局樹中，所以佈局樹既是輸入內容，亦是輸出內容。
#### 分層
瀏覽器的頁面實際上被分成了很多圖層，這些圖層疊加後合成了最終的頁面。
* **渲染引擎還需要為特定的節點生成專用的圖層，並生成一棵對應的圖層樹（LayerTree）。**

![](https://i.imgur.com/rl8wl76.png)
* 並不是佈局樹的每個節點都包含一個圖層，如果一個節點沒有對應的層（EX.上圖span），那麼這個節點就**從屬於父節點**的圖層。

* 滿足以下其中一項，渲染引擎會為特定的節點創建新的圖層
    1. 擁有**層疊上下文屬性的元素**會被提升為單獨的一層，Ex.`position`，`opacity`。
        *  層疊上下文：
            * 頁面是個二維平面，但是層疊上下文能夠讓HTML 元素具有三維概念，這些HTML元素按照自身屬性的優先級分佈在垂直於這個二維平面的z 軸上。
![](https://i.imgur.com/eOEHlx9.png)
    2. 需要**剪裁（clip）** 的地方也會被創建為圖層。
        * div 的大小限定為200 * 200 像素，而div 裡面的文字內容比較多，文字所顯示的區域肯定會超出200 * 200 的面積，這時候就產生了剪裁，如果出現滾動條，滾動條也會被提升為單獨的層。
![](https://i.imgur.com/CBRaYFc.png)
        
#### 圖層繪製
* 完成圖層樹的建構之後，渲染引擎會對圖層樹中每個圖層進行繪製。
* 會把一個圖層的繪製拆分成很多小的繪製指令，然後在把這些指令按照順序組成一個待繪製列表。
![](https://i.imgur.com/zQKg4tK.png)


#### 柵格化(raster)操作
* 繪製一個元素通常需要好幾條繪製指令，因為每個元素的背景、前景、邊框都需要單獨的指令去繪製。
* 繪製列表只是用來記錄繪製順序和繪製指令的列表，而**實際上繪製操作是由渲染引擎中的合成執行緒來完成的**。
* 當圖層的繪製列表準備好之後，主執行緒會把該繪製列表**提交(commit)** 給合成執行緒。

#### 分塊
![](https://i.imgur.com/Yt7FJTt.png)
* 合成執行緒會將較大、較長的圖層（一屏顯示不完，大部分不在視口內）劃分為圖塊（tiles, 256 * 256, 512 * 512）。
* 合成執行緒會按照視口附近的圖塊來優先生成位圖，實際生成位圖的操作是由**柵格化**來執行的。
    * 柵格化：
        * 是指將圖塊轉成位圖。
        * 圖塊是柵格化的最小單位，渲染程序維護了一個柵格化的執行緒池，所有的圖塊柵格化都是在執行緒池內執行的。
    * 快速柵格化：
        * 通常柵格化過程都會**使用GPU來加速生成**，使用GPU生成位圖的過程叫快速柵格化，或者GPU柵格化，生成的位圖被保存在GPU記憶體中。
* GPU操作是運行在GPU程序中，如果柵格化操作使用了GPU，那麼最終生成位圖的操作是在GPU中完成的，這就涉及到了跨程序操作。

#### 合成和顯示
* 一但所有圖片都被柵格化，合成執行緒就會生成一個繪製圖塊的命令-**「DrawQuad」**，然後將該命令提交給瀏覽器程序。
* 瀏覽器程序裡面有一個叫**viz**的組件，用來接收合成執行緒發過來的DrawQuad命令，將其頁面內容繪製到記憶體中，最後再將記憶體顯示屏幕上。
![](https://i.imgur.com/mb2p9Lh.png)